---
title: "Getting started"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Visualize tweet tree}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE, eval=TRUE}
knitr::opts_chunk$set(
  # eval=TRUE,
  eval=FALSE,
  # echo=TRUE,
  collapse = TRUE,
  # cache = TRUE,
  comment = "#>"
)

pic_path <- "visualize_tree_files"
```

This vignette shows how {rtweettree} can be used to generate network graphs visualizing the reactions on a tweet (replies, quotes and favorites) as a tree. The nodes correspond to tweets and the users who interact with them with these reactions. 


## Load packages

The following libraries are loaded:

```{r libs, eval = TRUE, message=FALSE}
library(dplyr)
library(rtweettree)
library(ggraph)
library(tidygraph)
library(ggiraph)
```

## Scraping 

Unfortunately, the twitter API (rtweet is based on) doesn't allow to scrape all sub tweets. 
For small amounts of replies/quotes/likes this often results in no subtweets at all.
On the other hand, for large amounts it can take a long time due to rate limits (please refer to [the twitter developer website on rate limits](https://developer.twitter.com/en/docs/basics/rate-limiting), or the [documentation of the rtweet functions](https://docs.ropensci.org/rtweet/reference/index.html)).

### Scrape tweets

Tweets on twitter are uniquely classified via the status id:

```{r status_id}
# Replace this number by any status_id (the last number in the twitter.com url of a tweet):
main_status_id <- "1438481824922181635"
```

The corresponding information on twitter is acquired via `rtweet::lookup_statuses`:

```{r scrape}
df_main_status <- rtweet::lookup_statuses(main_status_id)
```

The function `search_tree()` calls the recursive function `add_tree_level()` for the status ids of all resulting subtweets until all available information was scraped from twitter:

```{r scrape_tree}
# Scrape available subtweets:
df_tree <- search_tree(main_status_id)
```

### Scrape timelines

The timelines of all users involved are scraped:

```{r scrape_timelines}
tree_ids <- df_tree$user_id %>% unique()
# Scrape the timelines of the users scraped:
```


```{r scrape_timelines2, include=FALSE}
# TODO: repair!
# df_tls <- scrape_timelines(tree_ids)
```


```{r scrape_timelines3}
df_tls <- rtweet::get_timelines(tree_ids)
```

### Scrape likes

The favorites of all users involved are scraped:

```{r scrape_favs}
df0 <- df_main_status %>%
  dplyr::filter(status_id == main_status_id) %>%
  dplyr::select(to = status_id, user_id) %>%
  dplyr::mutate(from = "root", type = "root")
tweet_edges <-
  find_connections_rec(dplyr::bind_rows(df_tree, df_tls), df0)
ids <- tweet_edges$user_id %>% unique()
# Scrape the likes of the users scraped:
df_favs <- scrape_favs2(ids, main_status_id)
```

### Retweets
```{r}
tweet_ids <- list(df_tls, df_favs, df_main_status) %>% dplyr::bind_rows() %>% pull(status_id) %>% unique()
df_retweets <- tweet_ids %>% map_dfr(~rtweet::get_retweets(.x)) %>% tibble::as_tibble()
```



```{r scrape_favs_save, include=FALSE}
usethis::use_data(df_main_status, overwrite = TRUE)
usethis::use_data(df_tls, overwrite = TRUE)
usethis::use_data(df_tree, overwrite = TRUE)
usethis::use_data(df_favs, overwrite = TRUE)
usethis::use_data(df_retweets, overwrite = TRUE)
```

## Create tbl_graph object

The relevant twitter information of these tweets is translated into a tidygraph network object: 

```{r tbl_graph, eval=TRUE, message=FALSE}
# TODO: adapt to new structure
l <- list(df_main_status, df_tree, df_tls, df_favs, df_retweets) %>% 
  purrr::set_names(c("main_status", "tree", "tls", "like", "retweet")) %>% 
  dplyr::bind_rows(.id = "type")

class(l) <- c("rtweettree_data", class(l))
g <- rtweettree_tbl_graph(l)
```


```{r tbl_graph2, eval=TRUE}
g
```

Now we can make use of the full power of tidygraph, e.g.,  add a column to the nodes tibble, showing how far the respective node is from the main tweet in the graph:

```{r data_manip, eval=TRUE}
g <- g %>%     
  # calculate the distance to the tree root with tidygraph:
  mutate(dist_to_root = node_distance_from(node_is_source()))
g
```




```{r tbl_graph_save, include=FALSE}
usethis::use_data(g, overwrite = TRUE, internal = TRUE)
```



## Visualize graphs

Please make sure not to publish information from Twitter you are not allowed to and to comply in strict accordance with the [twitter developer terms](https://developer.twitter.com/en/developer-terms/more-on-restricted-use-cases)! The example rtweet data in this article only contains the tweets of three dummy accounts I created. But probably you're not allowed to publish all this information for the `main_status_id` of any other tweet.

```{r load_g, eval=TRUE, include=FALSE}
# load g from internal dataset
# g <- rtweettree:::g
```

The generated graph object consists of nodes representing tweets and users. These are connected by edges that can be 

* replies & quotes (connecting tweets),
* "by" connecting the author to his respective tweet, and 
* "like"/"retweet" connecting the user to the tweet he liked/retweeted. 

### Hierarchical tree plot with ggraph

We can generate a simple tree graph of the various tweets and users with:

```{r simpleplot}
g %>% 
  ggraph() + 
  geom_node_label(aes(label = label, color = type), repel = TRUE) + 
  geom_edge_link()
```

```{r ggraph2, eval=TRUE, fig.width=8, fig.height=6}

g1 <- ggraph(g)

g1 +
  geom_edge_diagonal(aes(color= type)) +
  scale_edge_colour_hue(name = "action") +
  geom_node_point(aes(
    # we color the nodes by dist_to_root that we calculated above for the tbl_graph object:
    color = dist_to_root,
    shape = type
  )) + 
  scale_color_viridis_c(direction = -1) + 
  theme(legend.position = "bottom")
```


### Using ggiraph

With ggiraph we can generate an interactive tree graph:


```{r ggiraph, eval=TRUE, results='asis'}
# Hack to put all user nodes on the bottom line of the graph:
g1$data$y[g1$data$type == "user"] <- min(g1$data$y)


# Add on click information to the graph nodes:
g1$data$onclick  <- glue::glue('window.open("{g1$data$url}")')

# Reproduce the above ggraph using the according ggiraph components:
g2 <- g1 +
  geom_edge_diagonal(aes(color= type)) +
  ggforce::geom_mark_rect(aes(x = g1$data$x,
                              y = g1$data$y,
                              # filter = type == 'user',
                              color = g1$data$type)
  ) +
  scale_color_discrete(name = "type") +
  geom_point_interactive(aes(x=g1$data$x,
                                      y = g1$data$y,
                                      color = type,
                                      data_id = g1$data$screen_name,
                                      tooltip = g1$data$label,
                                      onclick = g1$data$onclick),
                                  size = 3) +
  ggtitle("Hover over the nodes to see the tweets/user names.", 
          subtitle = "Click on the nodes to open the tweets/users on twitter.com")
p <- girafe(code = print(g2), width_svg = 6, height_svg = 5)

p <- girafe_options(x = p,
                    opts_zoom(min = 0.3, max = 5),
                    opts_hover(girafe_css(css = "stroke:yellow;",
                                          point = "stroke-width:6px")))

p
```

### Customizing `autoplot()`

We can also customize the ggraph object by passing arguments to the autoplot methods, e.g. by 

* not including the profile pictures (`add_profile_pics = FALSE`)
* or using another [layout](https://ggraph.data-imaginist.com/articles/Layouts.html) (`layout = "stress"`)

```{r, eval=TRUE, message=FALSE}
autoplot(l, add_profile_pics = FALSE, layout = "stress")
```

